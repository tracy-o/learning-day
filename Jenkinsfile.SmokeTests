#!/usr/bin/env groovy

library 'BBCNews'

def result = 'PASSED'
def exception

def cronlist = BRANCH_NAME == 'master' ? '''
30 09 * * 1-5 % ENVIRONMENT=test;
00 16 * * 1-5 % ENVIRONMENT=test;
''' : ''

node {
  cleanWs()
  checkout scm

  properties([
    buildDiscarder(logRotator(numToKeepStr: '30', daysToKeepStr: '3', artifactNumToKeepStr: '30', artifactDaysToKeepStr: '3')),
    disableConcurrentBuilds(),
    pipelineTriggers([parameterizedCron(cronlist)]),
    parameters([
        choice(name: 'ENVIRONMENT', choices: ['test', 'live'], description: 'The environment to run the tests against'),
        choice(name: 'TARGET', choices: ['all', 'belfrage', 'cedric-belfrage', 'bruce-belfrage'], description: 'The target to run the tests against.'),
        string(name: 'SLACK_MESSAGE', defaultValue: '', description: 'Optionally enter a value to send the result along with this message to the Belfrage slack channel.'),
        string(name: 'DEPLOYMENT_ID', defaultValue: '', description: 'Optionally enter the cosmos deployment ID to report the status of this smoke test to.'),
        string(name: 'REVISION', defaultValue: '', description: 'Optionally enter the short sha of the git commit to run the tests from.'),
        string(name: 'DELAY', defaultValue: '0', description: 'Optionally delays the start of the smoke test for the amount of seconds given in the parameter.')
      ])
  ])

  stage('Checkout revision') {
    if (params.REVISION ==~ /^([a-zA-Z0-9]){7}$/) {
      sh "git checkout ${params.REVISION}"
    } else {
      echo "Not a short SHA, running tests from the HEAD of the branch"
    }
  }

  stage('Run Smoke tests') {

    // waiting for as many seconds specified in DELAY parameter
    try {
      echo "waiting ${params.DELAY} seconds"
      sleep(params.DELAY.toInteger())
    } catch (err) {
      echo "Error while attempting to stall tests, starting tests immediately"
    }

    docker.image('qixxit/elixir-centos').inside("-u root") {
      sh 'mix deps.get'

      try {
        ansiColor('xterm') {
          if (params.TARGET == 'all') {
            sh "set -o pipefail ; mix smoke_test --group-by spec --bbc-env ${params.ENVIRONMENT} | tee smoke_test_output.txt"
          } else {
            sh "set -o pipefail ; mix smoke_test --group-by spec --bbc-env ${params.ENVIRONMENT} --only stack:${params.TARGET} | tee smoke_test_output.txt"
          }
        }
      } catch (err) {
        result = 'FAILED'
        exception = err
      }
    }
  }

  if (result == 'FAILED') {
    stage('Report result to slack') {
      def testFigures = "smoke test output not available"

      try {
        if (fileExists('smoke_test_output.txt')) {
          testFigures = sh(script: "cat smoke_test_output.txt | tail -n 5 | head -n 2", returnStdout:true).trim()

          if (!(testFigures.contains("tests") && testFigures.contains("failures"))) {
              println("Test figures don't match regex")
              testFigures = "failed to get results from test output"
          }
          sh 'rm smoke_test_output.txt'
        }
      } catch (err) {
        println("Couldn't find test results")
        println(err)
      }

      currentBuild.description = "${params.ENVIRONMENT} ${result}"
      slackSend channel: "#team-belfrage", message: "Belfrage Smoke tests on *${params.ENVIRONMENT}* ${result}\n${testFigures}\n<${env.RUN_DISPLAY_URL}|more info>\n${params.SLACK_MESSAGE}"
    }
  }

  if (params.DEPLOYMENT_ID != '') {
    stage('Tag cosmos deployment') {
      tagType = (result == 'FAILED') ? 'fail' : 'pass'
      BBCNews.labelCosmosDeployment(params.DEPLOYMENT_ID, tagType, 'Belfrage smoke test result', env.RUN_DISPLAY_URL)
    }
  }

  stage("clean up after ourselves") {
    docker.image('qixxit/elixir-centos').inside("-u root") {
      sh "rm -rf ${env.WORKSPACE}/{deps,_build,local.log}"
    }
    cleanWs()
    dir("${env.WORKSPACE}@libs") {
      deleteDir()
    }
    if (exception != null) {
      throw exception
    }
  }
}
